# [부스트캠프 16일차]

## 주간 자기 회고 시간 중 느낀것

오늘 설문조사에 흥미로운 주제의 질문이 나왔고, 나름 열심히 고민하여 제출하였다. 

실제로도 내가 기업을 선택하는데 중요시 보는 요소들이다. 

## 좋은 회사에 대한 기준

저는 다음과 같은 기준을 갖고 회사를 선택합니다.

- 우수한 개발자들의 모임
- 공유의 가치를 아는 기업
- 좋은 개발 문화를 갖은 기업 (코드리뷰, 다양한 스터디, 더 나은 코드를 위한 고민
- 회사의 비전이 명확하고, 해결하고자 하는 문제가 명확한 기업
- 기업의 사회적 책임을 이해하고 행하는 기업

각각의 요소들에 대해 자세히 설명하겠습니다.

### 우수한 개발자들의 모임

:: 신입부터 CTO까지 개발에 열정을 갖고 일하는, 월급 루팡 없이 1인분 이상의 가치를 만들어 내는 집답

### 공유의 가치를 아는 기업

:: 지식과 경험을 공유하는것의 중요성을 아는 회사.
:: 기술 블로그, 다양한 커뮤니티 활동, 다양한 발표 등

### 좋은 개발 문화를 갖은 기업

:: 코드리뷰, 다양한 스터디, 더 나은 코드를 위한 고민 을 당연시 하는 회사

:: 개발 지식을 공유하는 문화가 갖춰진 회사

### 회사의 비전이 명확하고, 해결하고자 하는 문제가 명확한 기업

:: 큰 그림을 그리고 있는 기업. 

:: 그 그림이 회사가 궁극적으로 해결하려는 문제를 포함하고 있는 기업

### 기업의 사회적 책임을 이해하고 행하는 기업

:: CSR을 이해하고, 더 나은 세상을 만들기 위해 고민하는 기업

## 챌린지 중 느낀것

> 오늘은 코드를 작성하기 앞서 어떻게 구현할지 구성을 먼저 생각하고 시작했다. 

결과는 만족스러웠다. 

충분히 설계에 대한 고민을 하고 들어가니, 무엇을 해야 할지 명확했고, 문제가 생겨도 체크 포인트로서 활용할 수 있었다. 

조건에서 중요한 부분들을 내 나름대로 1차 가공 하였다. 

그 후 어떻게 데이터가 흐르고 처리될지 고민을 하였다. 

물론 아래 방식도 처음부터 완벽할 순 없었고, 코드를 작성하며 수정을 계속하였다. 

그러나, 어느정도 큰 틀이 잡혀 있었고 TDD를 활용하여 매 기능구현 마다 테스트를 작성 하였기에 수정이 크게 어렵지 않았다. 

### 조건

- 배열안에는 배열, 숫자, 문자열, null 타입이 올 수 있다.
    - 이 이외에는 Error를 방출하자
    - 어떻게 문자열을 배열, 숫자, null로 구분할까
    - instanceof / typeof 보다는 regex를 사용해보자

### 데이터의 흐름

- 첫 줄에 `[` 이 들어오면, 끝 줄에 `]` 이 들어와야 한다.
    - 이상이 없다면, 이는 `array` 이다
    - `array` 인 경우, `[` 과 `]` 를 맨 앞뒤에 추가한다.
    - `array` 인 경우, comma를 찾아 분리한다.
    - 분리된 배열을 다시 재귀? 반복?

- 첫 줄에 `[` 이 오지 않았다면, 이는 `number`, `string`, `null` 중에 하나이다
    - 만약,  `" "` 안의 모든 내용이 `null` 과 일치한다면, `null` 이다
    - 만약, `" "` 안의 모든 내용이 `Regex` 로 number 형티임이 증명된다면, 이는 `number` 이다
        - `number` 의 범위를 어디까지 둘지 고민해본다.
        - 10진수를 넘어가 2진수, 8진수, 16진수도 지원할 것인가?
    - `null` 과 `number` 를 제외한 모든 경우는 단순 `string` 이다
    - 종료

### 구현 중 고민과 선택

1. `ArrayParser` 의 결과는 객체가 아닌 배열을 반환한다.

2. type `array` 를 제외한 모든 type은 `child:[]` 를 갖지 않는다.

- 이렇게 하는게 조금 더 자연스러운것 같다.
- array는 child를 갖을 수 있지만, 나머지 자료형은 child를 갖을 수 없다.

3. Test도구는 Jest를 사용하였다.

- 사용한 이유는, 챌린지 기간동안 자주 사용하여 익숙하였기 때문.

4. 전체 파일구조는 `Compiler` 폴더안에

- `tokenizer`, `lexer`, `parser` 에 대한 파일이 각각 존재.
- 각각의 기능에 대해 `.test.js` 확장자로 테스트 파일이 존재.
- `Compiler/index.js` 를 통해 통합하여, 통합 테스트 파일이 존재.

5. root dir 에서 Compiler를 `require`하여 사용.

- 다만, 예제의 코드와 폴더명이 다르기 때문에 다음과 같이 별명을 제공.
`const { compile: ArrayParser } = require('./Compiler');`

6. 재귀를 사용하지 않는다.

- 가정에서 배열이 무한 중첩된 형태도 해석되야 하는데,
- 재귀가 너무 많이 쌓이게 되면 메모리가 터질것 같았다.
- 단순히 루프를 돈다.

7. 루프를 돌며 `result` 객체의 현재 위치와 이전 위치를 저장하며 순회한다.

- 현재 위치는 `currentPosition` 에 저장한다.
- 이전까지 접근한 위치는 `positions` 에 `stack` 형태로 저장 된다.
    - 이를 통하여, 이전 위치로 가고 싶다면 `stack` 최상단 요소를 `pop()` 하여 `currentPosition`을 대체하면 된다.

## 회고

오늘은 진짜 공부부터하고 들어갔다. 

지난주에 구현에만 급급하여 제대로된 공부를 하지 못했다는 반성을 반복하지 않기위해서,

오늘은 아예 코드 구현은 뒤로 미루고 4시까지 개념만 공부하였다. 

특히, 컴파일러는 태어나서 처음 본 개념이였는데, 오래 걸렸지만 대략적인 구조를 파악하는덴 충분한 시간이였다. 

4시까지 코드를 한줄도 작성하지 않아 실제 코드를 작성하려 할때 굉장히 압박을 느꼈는데, 다 하지 못하더라도 최선을 다하자는 생각을 갖고 임하니 별 무리 없이 개발을 완료하였다. 

특히, 대략적인 구조를 파악하며 tokenizer, lexer, parser의 구분을 나름 명확히 하게 되니, 실제 코드를 작성할때도 관심사의 분리가 명확하여 수월하였다. 

오늘 test 코드는 과제중에 하나였는데, TDD로 하려 노력했고 어느정도 성공적이였다. 

신기하게도 4시부터 시작하였지만, 7시에 끝날 수 있었고 지난주 금요일에 우리팀이 마무리 짓지 못했던 릴레이 프로젝트를 손볼 시간이 있었다. 

이에 대한 후기는 다음에 올리도록 하겠다. 

오늘도 정말 많이 배우는 하루였다. 

내일도 많은 경험을 가져갈 수 있다면 좋겠다. 

+ 컴파일러에 대한 이해가 부족하여 방황을 하고 있을 때, 마음씨 좋은 부캠원 한분이 다가와서 친절하게 설명을 해주셨다. 본명을 밝히긴 그렇지만 항상 큰 도움이 되고 있다. 
